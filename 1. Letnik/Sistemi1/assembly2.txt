JMP main

number:
	DW 1 ; number[0]
    DW 2 ; number[1]
    DW 3
    DW 4
    DW 5
    DW 6
    DW 7
    DW 8
    DW 9
    DW 10 ; number[9]
    
main:
	MOV D, number ; naslov 0-tega elementa
    MOV C, 0 ; indeks i

loop:
	CMP C, 10
    JAE break
    MOV A, [D]
    MUL 10
    MOV [D], A
    ADD D, 2
    INC C
    JMP loop
    
break:
	HLT

---------------------------------------------------------
JMP main

ORG 0x0100
number:
	; Prostor za 100 števil
    ; 2000 zlogov (bytov)
ORG 0x08D0

main:
	MOV D, number ; naslov 0-tega elementa
    MOV C, 0 ; indeks i

loop:
	CMP C, 1000
    JAE break
    MOV A, C ; A <- i
    SHL A, 1 ; A <- 2*i
    ADD A, 2 ; A <- 2*i + 2
    MOV [D], A ; number[i] = 2*i
    INC C
    ADD D, 2 ; Naslov naslednjega elementa
    JMP loop
    
break:
	HLT
---------------------------------------------------------
JMP main

ORG 0x0100
number:
	; Prostor za 100 števil
    ; 2000 zlogov (bytov)
ORG 0x08D0

main:
	MOV D, number ; naslov 0-tega elementa
    MOV C, 2 ; indeks i = 2

loop:
	CMP C, 2000
    JAE break
    MOV [D], C
    ADD C, 2
    ADD D, 2
    JMP loop
    
break:
	HLT
---------------------------------------------------------
JMP main

s: DB "Hello world!"
   DB 0
   
len: DW 0

; length(s) vrne dolžino niza s
; Parameter s (kazalec/naslov prvega znaka) prejme
; preko registra C
; Dolžino niza (16-bitno celo število) vrne preko
; registra A
length:
	MOV  A, 0 ; Števec znakov
loop:
	MOVB BL, [C] ; Preberemo trenutni znak
    CMPB BL, 0 ; Ali smo prebrali terminalno ničlo
    JE return
	INC A ; Štejemo trenutni znak
    INC C ; Kazalec na naslednji znak
    JMP loop
    
return:    
    RET
    

main:
	MOV SP, 0x0FFF ; Inicializacija sklada
	MOV C, s ; Parameter s
    CALL length
    MOV [len], A
    HLT
---------------------------------------------------------
loop:
	IN 5 ; Preberemo status tipkovnice
    CMP A, 0 ; Ali je prišlo do dogodka
    JE loop ; Če ne, beri ponovno
    AND A, 1 ; Maskiramo keydown event
    CMP A, 1 ; Ali je keydown?
    JE display_key
    MOVB [0x1000], 0 ; Če ni, pobrišem prvo celico prikazovalnika
    JMP loop ; Ponovno preberi status
    
display_key:
    IN 6 ; Preberemo kodo ASCII
    MOVB [0x1000], AL ; Premakni kodo tipke na prikazovalnik
    JMP loop ; ponovno preberi
	HLT
---------------------------------------------------------
JMP main
JMP isr

isr:
    PUSH A ; ISR uporablja register A, zato ga shranimo na sklad
	; Ker edino tipkovnica lahko proži prekinitve,
    ; nam pri tej nalogi ni treba preveriti, katera
    ; naprava je to prekinitev sporžila
    IN 5 ; Preberemo status tipkovnice
    AND A, 1 ; Maskiramo dogodek keydown
    CMP A, 1 ; Ali je dogodek keydown
    JE display_key
    IN 6 ; Preberemo KBDDATA, zato da se pobriše KBDSTATUS
    MOVB [0x1000], 0 ; Pobrišemo celico
    JMP iret
    
display_key:
	IN 6 ; Preberemo (KBDDATA) kodo pritisnjene tipke
    MOVB [0x1000], AL ; Izpišemo kodo ASCII
    
iret:
	; Preko registra IRQEOI sporočimo, katero zahtevo smo obdelali
    MOV A, 1 ; Maska za tipkovnico
    OUT 2 ; Masko zapišemo v IRQEOI in s tem umaknemo zahtevo
	; Ker je KBDSTATUS = 0, smo preko IRQEOI umaknili zahtevo za prekinitev.
    POP A ; restavriramo vrednost registra A
    IRET
    
main:
	MOV SP, 0x0FFF ; Inicalizacija sklada
    MOV A, 1 ; Maska za tipkovnico
    OUT 0 ; Omogočimo prekinitve samo tipkovnici
    STI ; Omogočimo prekinitve globalno
	HLT
---------------------------------------------------------
JMP main
JMP isr

isr:
	PUSH A
	; Časovnik je edina naprava, ki sme prožiti prekinitev
    ; zato nam ni treba preverjati IRQSTATUS
    MOV AL, [0x1000] ; Kaj je trenutno na zaslonu
    CMPB AL, '9' ; Ali smo dosegli 9?
    JNE noreset
    MOVB AL 0x2F ; En znak pred '0'
noreset:
    INCB AL ; Povečamo ASCII kodo za 1
    MOVB [0x1000], AL ; Na zaslon damo novo ASCII kodo
    ; Sedaj še umaknemo zahtevo za prekinitev
    MOV A, 2 ; Maska za časovnik
    OUT 2 ; zapišemo jo v IRQEOI in s tem umaknemo zahtevo
    POP A
	IRET

main:
	MOV SP, 0x0FFF
    MOVB [0x1000], '0'
    MOV A, 1000 ; Prekinitev vsakih 1000 urnih period
    OUT 3 ; Zapišemo v TMRPRELOAD
    MOV A, 2 ; Maska za časovnik
    OUT 0 ; Zapišemo v IRQMASK - omogočimo prekinitve časovnika
    STI ; M = 1
    HLT
---------------------------------------------------------
JMP main

main:
	MOV A, 2 ; vključimo graficno kartico v načinu BITMAP
    OUT 7
	MOV A, 3 ; pobrišemo zaslon
    OUT 7
    MOV A, 32639
    OUT 8
    MOV A, 31
    OUT 9
    HLT
---------------------------------------------------------
JMP main

main:
	MOV A, 2 ; vključimo graficno kartico v načinu BITMAP
    OUT 7
	MOV A, 3 ; pobrišemo zaslon
    OUT 7

loop:
	IN 5
    CMP A, 0
    JE loop
    AND A, 1
    CMP A, 1
    JE display
    JMP loop
    
display:
	IN 10
	OUT 8
    IN 10
    OUT 9
    JMP loop
    HLT
---------------------------------------------------------
JMP main

main:
	MOV A, 2
    OUT 7
    MOV A, 3
    OUT 7
    
	MOV B, 0 ; začetni VRAM naslov je 0
    MOV C, 255
loop:
	MOV A, B
    OUT 8 ; nastavimo VRAM naslov za rdečo
   	MOV A, 224 ; rdeča barva
    OUT 9 ; VIDDATA
    
    MOV A, C
    OUT 8 ; nastavimo VRAM naslov za rumeno
    MOV A, 252 ; rumena barva
    OUT 9 ; VIDDATA
    
    CMP B, 0xFFFF ; Alis smo izrisali zadnji pixel
    JE break
    ADD B, 257 ; Naslov naslednjega rdečega piksla
    ADD C, 255 ; Naslov naslednjega rumenega piksla
    JMP loop
    
break:
    HLT
---------------------------------------------------------
JMP main
JMP isr

; true (1) / false (0)
gor: DB 0 
dol: DB 0
levo: DB 0
desno: DB 0

isr:
	PUSH A
    IN 5 ; preberemo KBDSTATUS
    CMP A, 1 ; Ali je keydown?
    JNE keyup ; če ni, skoči na keyup
    MOVB BL, 1 ; Eno od štirih tipk bom nastavil na true
    JMP setkey
    
keyup:
	MOVB BL, 0 ; Pritisnjeno tipko bom nastavil na false
setkey:
	IN 6 ; Katera tipka je bila pritisnjena?
    CMPB AL, '8' ; Ali je bila 8?
    JNE check2 ; Če ne preveri tipko 2
    MOVB [gor], BL ; spremenim  stanje tipke gor
    JMP done
check2:
	CMPB AL, '2'
    JNE check4
    MOVB [dol], BL
    JMP done
    
check4:
	CMPB AL, '4'
    JNE check6
    MOVB [levo], BL
    JMP done
    
check6:
	CMPB AL, '6'
    JNE done
    MOVB [desno], BL
    
done:
	MOV A, 1 ; Umaknemo zahtevo po prekinitvi
    OUT 2
	IRET

slevo: DB "LEVO\0x00"
sdesno: DB "DESNO\0x00"
sgor: DB "GOR\0x00"
sdol: DB "DOL\0x00"
slevogor: DB "LEVO GOR\0x00"
sdesnogor: DB "DESNO GOR\0x00"
slevodol: DB "LEVO DOL\0x00"
sdesnodol: DB "DESNO DOL\0x00"

main:
	MOV SP, 0x0FFF ; Inicializacija sklada

    MOV A, 1 ; Maska za prekinitve tipkovnice
    OUT 0 ; Omogočimo prekinitve tipkovnici
    STI ; Omogočimo prekinitve globalno
    
loop:
	MOVB AL, [levo]
    CMPB AL, 1
    JNE checkdesno
    MOVB AL, [desno]
    CMPB AL, 0
    JNE checkdesno
    MOVB A, [gor]
    CMP A, [dol]
    JNE checkdesno
    
checkdesno:
	HLT
---------------------------------------------------------
JMP main
JMP isr

vsync: DW 0 ; vsync = true (1) / false (0)

isr:
	PUSH A ; Shranimo originalno vrednost reg. A
	; Ni potrebno preverjati, katera naprava je prožila prekinitev
    MOV [vsync], 1 ; vsync = true
    MOV A, 4 ; Prekinitev grafične kartice
    OUT 2 ; IRQEOI - umaknemo zahtevo za prekinitev
    POP A ; Ponastavimo originalno vrednost reg. A
	IRET
    
; Funkcija wait_vsync() čaka na signal vysnc
wait_vsync:
wait_vsync_loop:
	MOV A, [vsync] ; Vrednost globalne spremenljivke vsync
    CMP A, 0 ; Ali je še vedno false?
    JE wait_vsync_loop
    DEC C ; Odštejemo en signal vsync
    MOV [vsync], 0 ; Zastavica je prebrana, zato jo umaknemo
    CMP C, 0 ; Ali je count že na 0
    JNE wait_vsync_loop ; Če ni, čakamo naprej
    RET

main:
	MOV SP, 0x0FFF ; Inicializacija sklada
	MOV A, 1 ; Številka besedilnega načina
    OUT 7 ; VIDMODE
    MOV A, 14 ; 7. stolpec, 1. vrstica
    OUT 8 ; VIDADDR
    MOV A, 0xFFFF ; Krožec bele barve
    OUT 9 ; Izrišemo simbol
    
    ; Omogočimo prekinitve grafični kartici
    MOV A, 4 ; Št. prekinitve za grafično kartico
    OUT 0 ; IRQMASK
    STI ; Omogočimo prekinitve globalno
    
    ; Počakamo 2 sekundi
    MOV C, 100 ; Čakamo 100 signalov vsync
    CALL wait_vsync ; wait_vsync(100)
    
    ; Animacija padanja
    MOV D, 14 ; Začeten položaj krožca
    
animation_loop:
    MOV A, D    ; Trenutni položaj
    OUT 8        ; Aktiviramo celico
    MOV A, 0    ; Prazen prostor.
    OUT 9        ; Pobrišemo krožec
    ADD D, 256    ; Premaknemo se v novo vrstico.
    CMPB DH, 16 ; Ali smo že v 16. vrstici
    JB noreset
    MOV D, 14 ; Krožec postavimo nazaj na vrh
noreset:
    MOV A, D    ; Novi položaj
    OUT 8        ; Aktiviramo celico
    MOV A, 0xFFFF ; krožec bele barve.
    OUT 9        ; izrišemo
    MOV C, 25
    CALL wait_vsync ; wait_vsync(25)
    JMP animation_loop
    HLT   
---------------------------------------------------------
JMP main
JMP isr

vsync: DW 0 ; vsync = true (1) / false (0)

isr:
	PUSH A ; Shranimo originalno vrednost reg. A
	; Ni potrebno preverjati, katera naprava je prožila prekinitev
    MOV [vsync], 1 ; vsync = true
    MOV A, 4 ; Prekinitev grafične kartice
    OUT 2 ; IRQEOI - umaknemo zahtevo za prekinitev
    POP A ; Ponastavimo originalno vrednost reg. A
	IRET
    
; Funkcija wait_vsync() čaka na signal vysnc
wait_vsync:
wait_vsync_loop:
	MOV A, [vsync] ; Vrednost globalne spremenljivke vsync
    CMP A, 0 ; Ali je še vedno false?
    JE wait_vsync_loop
    DEC C ; Odštejemo en signal vsync
    MOV [vsync], 0 ; Zastavica je prebrana, zato jo umaknemo
    CMP C, 0 ; Ali je count že na 0
    JNE wait_vsync_loop ; Če ni, čakamo naprej
    RET

str: DB "The Light at the End of the World"
	 DB 0

main:
	MOV SP, 0x0FFF ; Inicializacija sklada
	MOV A, 1 ; Številka besedilnega načina
    OUT 7 ; VIDMODE
    
    ; Izpišemo niz "str" na lokacijo (16,7)
    MOV C, str ; Kazalec na niz ki ga izpisujemo
    MOV D, 0x0720 ; Naslov celice (16,7)

loop_str:
	MOV A, D ; Aktiviramo trenutno celico
    OUT 8
	MOVB AH, [C] ; Trenutna črka
    CMPB AH, 0 ; Ali smo že na koncu niza
    JE loop_str_break
    MOVB AL, 252 ; Rumena
    OUT 9 ; Izpišemo črko
    INC C ; Naslednja črka
    ADD D, 2 ; Naslednja celica
    JMP loop_str
 
loop_str_break:
	
    ; Omogočimo prekinitve grafični kartici
    MOV A, 4 ; Št. prekinitve za grafično kartico
    OUT 0 ; IRQMASK
    STI ; Omogočimo prekinitve globalno
    
    ; Animacija premikanja besedila
    
animation_loop:
	MOV A, 0xA302 ; Naslov za horizontalni odmik
    OUT 8 ; VIDADDR (Trenutna vrednost se pojavi v reg. VIDDATA)
    IN 9 ; VIDDATA preberemo v reg. A
    ADD A, 2 ; Odmik povečamo za dva piksel
    CMP A, 784 ; Če še ni smo prišli do odmika
    JB no_window_reset ; Ne ponastavimo okna
    MOV A, 0
no_window_reset:
    OUT 9 ; Zapišemo nazaj v 0xA302
    MOV C, 1
    CALL wait_vsync ; wait_vsync(25)
    JMP animation_loop
    HLT
---------------------------------------------------------
JMP main

str: DB "ABBA\x00"

ghost:
	DB "\x00\x00\x03\xC0\x0F\xF0\x1F\xF8\x33\xCC\x21\x84\x2D\xB4\x6D\xB6"
	DB "\x73\xCE\x7F\xFE\x7F\xFE\x7F\xFE\x7F\xFE\x7B\xDE\x31\x8C\x00\x00"

main:
	MOV A, 1
    OUT 7
    
    MOV C, str
    MOV D, 0
loop_str:
	MOV A, D
    OUT 8
    MOVB AH, [C]
    CMPB AH, 0
    JE loop_str_break
    MOVB AL, 255
    OUT 9
    INC C
    ADD D, 2
    JMP loop_str
    
loop_Str_break:
	; Prekopirajmo definicijo duhca iz RAM-a (labela ghost) v
    ; VRAM od naslova 0x88220 dalje (32 bytov), čez črko "A"
    MOV C, ghost ; Kazalec na duhca
    MOV D, 0x8820 ; Kazalec na VRAM, kjer je črka "A"
    MOV B, 16 ; Števec že prekopiranih zlogov (bytov)
loop_ghost:	
	CMP B, 0 ; Ali smo že prekopirali vseh 16 besed
    JE loop_ghost_break
    MOV A, D ; Trenutni naslov v VRAM-u
    OUT 8 ; Aktiviramo 
    MOV A, [C] ; Trenutna beseda v RAM-u
    OUT 9 ; Prepišemo
    ADD C, 2 ; Naslednja beseda v RAM-u
    ADD D, 2 ; Naslednji naslov v VRAM-u
    DEC B ; Zmanjšamo števec besed
    JMP loop_ghost
    
loop_ghost_break:
	HLT
---------------------------------------------------------
JMP main

main:
	MOV A, 1
    OUT 7
    
    ; Izpišimo 100 črk A
    MOV C, 100 ; Števec
 	
loop_a:
	CMP C, 0 ; Ali smo že izspisali vseh 100 črk
    JE break_a
	IN 10 ; Naključno 16-bit število v reg. A
    AND A, 0x0F1E
	OUT 8 ; Aktiviramo naključen naslov v VRAM-u
    MOV A, 0x41E0 ; Črka A rdeče barve
    OUT 9 ; Izpišemo 
    DEC C ; Zmanjšamo števec
    JMP loop_a
 
break_a:
	; Redefinirajmo barvo 224
    MOV A, 0xA2A0
    OUT 8 ; Aktiviramo lokacijo z rdečo in zeleno komponento
    MOV A, 0xFF00 ; Nova definicija rdeče in zelene komponente
    OUT 9 ; Prepišemo v VRAM-u
    MOV A, 0xA2A1
    OUT 8 ; AKtiviramo lokacijo z modro in zeleno komponento
    MOV A, 0x00FF ; Nova definicija modre in zelene komponente
    OUT 9 ; Prepišemo v VRAM-u
    HLT
---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------
