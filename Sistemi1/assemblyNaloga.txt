JMP main
JMP isr

start: DB "Izberi operacijo a s m d        "
prvo: DB "Vnesi prvo stevilo"
drugo: DB "Vnesi drugo stevilo"


main:
	MOV SP, 0x0FFF ; Inicializacija sklada
    MOV A, 1 ; Maska za prekinitve tipkovnice
    OUT 0 ; Omogočimo prekinitve tipkovnici
    STI ; Omogočimo prekinitve globalno
    MOV C, start
    MOV D, 0x1000
    CALL print_start

    HLT

print_start:
	PUSH A
loop:
	MOVB AL, [C]
    MOVB [D], AL
    INC C
    INC D
    CMPB BL, [C]
    JNE loop
    
    POP A
    RET

print_prvo:
	PUSH A
    PUSH B
    MOV B, 0
loop2:
	MOVB AL, [C]
    MOVB [D], AL
    INC C
    INC D
    CMPB BL, [C]
    JNE loop2
    
    POP B
    POP A
    RET

-----------------------------------------------
JMP main
JMP isr

quit: DW 0 ; quit = false

isr:
    PUSH A ; The ISR will use register A .
    MOVB AL , [0x1000] ; Get the currently displayed character .
    INCB AL ; Increase its ASCII value .
    MOVB [0x1000] , AL ; Print out the new value .
    CMPB AL , '9' ; Check if ’9 ’ has been reached .
    JNE timerdone ; If not , we are done .
    MOV [quit] , 1 ; Otherwise set quit to true .

timerdone:
    MOV A , 2 ; Timer interrupt mask .
    OUT 2 ; Timer has been serviced .
    POP A ; Restore the register A .
    IRET ; Return from ISR .

main:
    MOV SP , 0x0FFF ; Initialize the stack pointer .
    MOVB [0x1000] , '0' ; Display ’0 ’ on display .
    MOV A , 5000 ; 1 second = 5000 clock cycles .
    OUT 3 ; Preset the timer to 5000.
    MOV A , 2 ; Timer interrupt mask .
    OUT 0 ; Set the mask .
    STI ; Enable interrupts .
loop:
    MOV A , [quit] ; Read the global quit variable .
    CMP A , 1 ; Check it ’ s value .
    JE break ; If true , break the loop .
    JMP loop ; Otherwise , read the value again .
break:
	CLI ; Disable interrupts .
    
    
----------------------------------------------------
; Basic work
JMP main

main:
	MOVB [0x1000], '>'
	MOVB [0x100F], '@'
    MOV B, 0x1000
    MOV C, 14
loop:
    CMP C, 0
    JE loop_break
    DEC C
    JMP move
    JMP loop

move:
	MOVB [B], ' '
    INC B
    MOVB [B], '>'
	JMP loop
    
loop_break:
	HLT

----------------------------------------------------
; Bolj zahtevna
JMP main


arrow: DB " >>-->"
	   DB 0
       
end: DB "Bullseye"
	 DB 0

print:
	PUSH A
    PUSH C
    MOV C, 0
.loop:
	MOVB AL, [B]
    MOVB [D], AL
    INC B
    INC D
    CMPB CL, [B]
    JNZ .loop
    
    POP C
    POP A
    RET

main:
	MOV SP, 0x0FFF
	MOVB [0x100F], '@'
    MOV A, 0x1000
    MOV C, 10
loop:
	MOV D, A
    CMP C, 0
    JE loop_break
    DEC C
    JMP move

move:
	MOV B, arrow
	CALL print
    INC A
	JMP loop
    
loop_break:
	MOV B, end
    MOV D, 0x1010
    CALL print
	HLT

-------------------------------
; Z prekinitvami
JMP main
JMP isr

quit: DW 0 ; quit = false

arrow: DB " >>-->"
	   DB 0
       
end: DB "Bullseye"
	 DB 0

isr:
	PUSH B
    PUSH D
    
   	MOV D, C
    MOV B, arrow
	CALL print
    INC C
    MOV B, 0
    MOVB BL, [0x100E]
    CMPB BL, '>'
    JNE done
    MOV [quit], 1

print:
	PUSH A
    PUSH C
    MOV C, 0
.loop:
	MOVB AL, [B]
    MOVB [D], AL
    INC B
    INC D
    CMPB CL, [B]
    JNZ .loop
    
    POP C
    POP A
    RET

main:
	MOV SP, 0x0FFF
	MOVB [0x100F], '@'
    MOV B, arrow
    MOV D, 0x1000
    CALL print
    MOV C, 0x1000
    MOV B , 5000 ; 1 second = 5000 clock cycles .
    OUT 3 ; Preset the timer to 5000.
    MOV B , 2 ; Timer interrupt mask .
    OUT 0 ; Set the mask .
    STI ; Enable interrupts .
loop:
	MOV B, [quit]
    CMP B, 1
    JE break
    JMP loop
    
done:
    MOV B , 2 ; Timer interrupt mask .
    OUT 2 ; Timer has been serviced .
    POP D
    POP B ; Restore the register A .
    IRET ; Return from ISR .
    
    MOV B, end
    MOV D, 0x1010
    CALL print

break:
	CLI
    
---------------------------------------
; Program se poganja pri 5kHz

JMP main
JMP isr

quit: DW 0 ; quit = false

arrow: DB " >>-->"
	   DB 0
       
end: DB "Bullseye"
	 DB 0

isr:
	PUSH A
    PUSH D
    
   	MOV D, C
    MOV A, arrow
	CALL print
    INC C
    MOV A, 0
    MOVB AL, [0x100F]
    CMPB AL, '>'
    JNE done
    
    MOV [quit], 1

print:
	PUSH B
    PUSH C
    MOV C, 0
.loop:
	MOVB BL, [A]
    MOVB [D], BL
    INC A
    INC D
    CMPB CL, [A]
    JNZ .loop
    
    POP C
    POP B
    RET

main:
	MOV SP, 0x0FFF
	MOVB [0x100F], '@'
    MOV A, arrow
    MOV D, 0x1000
    CALL print
    MOV C, 0x1000
    MOV A , 5000 ; 1 second = 5000 clock cycles .
    OUT 3 ; Preset the timer to 5000.
    MOV A , 2 ; Timer interrupt mask .
    OUT 0 ; Set the mask .
    STI ; Enable interrupts .
loop:
	MOV A, [quit]
    CMP A, 1
    JE break
    JMP loop
    
done:
    MOV A , 2 ; Timer interrupt mask .
    OUT 2 ; Timer has been serviced .
    POP D
    POP A ; Restore the register A .
    IRET ; Return from ISR .
    MOV A, end
    MOV D, 0x1010
    CALL print

break:
	CLI
    